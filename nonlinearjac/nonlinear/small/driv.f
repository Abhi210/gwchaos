C ... SAMPLE DRIVER FOR LESNLS...
C LESNLS IS THE CODE FOR APPROXIMATING LYAPUNOV EXPONENTS
C OF (SMALL) NONLINEAR SYSTEMS.  IN THIS CASE, THE 
C JACOBIAN MATRIX MUST BE PROVIDED (SEE GETA)
      PROGRAM DRIV
      IMPLICIT NONE
C DECLARE VARIABLES NEEDED BY LESNLS
C VECTOR FIELD GIVEN IN GETF
C JACOBIAN MATRIX DEFINED IN GETA
      EXTERNAL GETF, GETA
      INTEGER M, N
      PARAMETER (M=3,N=3)
      DOUBLE PRECISION T0, TE, DT, TOLT,TOLQ,TOLL(N)
      DOUBLE PRECISION APPLES(N), Y0(M,N)
      INTEGER IPAR(13), IFLAG, IFDIM
      PARAMETER(IFDIM=M*M+11*M*N+13*M+8*N+63)
      DOUBLE PRECISION FWORK(IFDIM), X0(M), REARR(6)
      INTEGER I, INARR

      DOUBLE PRECISION ACC
C VARIABLES TO GET CPU TIME
C     INTEGER*2 HR1,HR2,MN1,MN2,SEC1,SEC2,HUN1,HUN2

CCCCCCC INPUT
C LORENTZ ICs
      X0(1)=0.0D0
      X0(2)=1.0D0
      X0(3)=0.0D0
C PARAMETERS FOR LORENZ SYSTEM, 
C Values of interest: (a) sigma=16, beta=4, rho=40 or 45.92 
C -- or classical -- (b) sigma=10, beta=8/3, rho=28
C     SIGMA
      REARR(1)=16.0D0
C     BETA
      REARR(2)=4.0D0
C     RHO
      REARR(3)=45.92D0
CCCCCCC VARIABLE STEP SIZE -->0, FIXED STEP SIZE -->1
      IPAR(1) = 0
C ERROR TOLERANCE ON TRAJECTORY
C      DO 2 I=1,M
C         TOLT(I) = 1.0D-8
       TOLT = 1.0D-8
C 2    CONTINUE
CCCCCCC FROM T0 TO TE --> IPAR(2)=0, IF IN ONE STEP MODE --> IPAR(2)=1
      T0 = 0.D0
      DT = 1.0D0*1.0D-2   
      TE = 1.0D+2
      IPAR(2) = 0
CCCCCCC IT IS FIRST CALL --> IS A NEW CALL
      IPAR(3) = 1
C TO USE DEFAULT ICS ON Y0, SET IPAR(4) = 0 
      IPAR(4)=0
CCCCCCC FWORK DIMENSION
      IPAR(5)=IFDIM
C FIRST, WE'LL INTEGRATE A BIT TO GET RID OF TRANSIENT    
      IPAR(6)=1
C DECIDE WHICH METHOD WANT TO USE FOR TRAJECTORY AND/OR LES
C   IPAR(8)=0 (DEFAULT) IS PROJECTION/DP5
C   IPAR(8)=1 IS HYBRID/DP5
C   IPAR(8)=2 IS PROJECTION/RK38
C   IPAR(8)=3 IS HYBRID/RK38
C   IPAR(8)=4 IS DISC QR/DP5
C   IPAR(8)=5 IS DISC QR/RK38
      IPAR(8)=0
C ERROR CONTROL ON TRAJECTORY IS DEFAULT (OR SET IPAR(10)=0)
      IPAR(10)=0
C INITIALIZE CODE THE VERY FIRST TIME
      CALL INIT(M,N,IPAR,T0,TE,FWORK,IFLAG)
      IF (IFLAG.NE.0) THEN
         PRINT *, 'IFLAG = ', IFLAG
         STOP
      END IF
C FIRST CALL TO GETTIM
C     CALL GETTIM(HR1, MN1, SEC1, HUN1)
      CALL LESNLS(GETF,GETA,M,N,APPLES,T0,TE,DT,X0,Y0,
     *            TOLT,TOLQ,TOLL,IPAR,FWORK,IFLAG,INARR,REARR)
      IF (IFLAG.NE.0) THEN
         PRINT *, 'IFLAG = ', IFLAG
         PRINT*, ' CURRENT T = ', T0,'  SOLUTION IS '
         WRITE(*,25) (X0(I),I=1,M)
         STOP
      ENDIF
C SECOND CALL TO GETTIM
C     CALL GETTIM(HR2, MN2, SEC2, HUN2)
      PRINT *, 'IFLAG = ', IFLAG
      PRINT*, ' FINAL T = ', T0,'  SOLUTION IS '
      WRITE(*,25) (X0(I),I=1,M)
      PRINT *, 'STEPS REJECTED = ', IPAR(12)
      PRINT *, 'NUMBER OF STEPS = ', IPAR(13)
C     WRITE (6,*) 'INITIAL TIME = ', HR1,MN1,SEC1,HUN1
C     WRITE (6,*) 'FINAL TIME = ', HR2,MN2,SEC2,HUN2
C NOW WE ARE READY TO FIND THE LYAPUNOV EXPONENTS
C TO INTEGRATE IN ONE STEP MODE: IPAR(2)=1
      IPAR(2) = 0
C IT IS A NEW CALL
      IPAR(3)=1
      IPAR(6)=0
C DECIDE WHICH METHOD TO USE TO APPROXIMATE EXPONENTS
C IN CASE YOU CHOSE IPAR(8)=0,1,2,3
C   IPAR(9)=0 (DEFAULT) IS NU-INTEGRATION 
C   IPAR(9)=1 IS COMPOSITE TRAP-RULE 
      IPAR(9)=0
C DECIDE HOW WANT TO CONTROL ERROR NOW
C ERROR CONTROL OPTIONS AVAILABLE ARE 
C IPAR(10)=0, 1, 2, 10, 20, 21, 210
C SEE DOCUMENTATION FOR MEANINGS AND COMPATIBILITIES
      IPAR(10)=0
      TE=1.0D+3+T0
C SET UP ERROR TOLERANCES FOR Q AND LEs IF NEEDED
      TOLQ=1.0D-8
      DO 5 I=1,N
 5       TOLL(I)=1.0D-8
C FIRST CALL TO GETTIM
C     CALL GETTIM(HR1, MN1, SEC1, HUN1)
C INTEGRATE FROM T0 TO TE
C CALL MAIN ROUTINE
 20   CALL LESNLS(GETF,GETA,M,N,APPLES,T0,TE,DT,X0,Y0,
     *            TOLT,TOLQ,TOLL,IPAR,FWORK,IFLAG,INARR,REARR)
      IF (IFLAG.NE.0) THEN
         PRINT *, 'IFLAG = ', IFLAG
         PRINT*, ' CURRENT T = ', T0,'  LYAP-EXPS ARE '
         WRITE(*,25) (APPLES(I),I=1,N)
         STOP
      ENDIF
      IF (IPAR(11).EQ.1) GOTO 20
C SECOND CALL TO GETTIM
C     CALL GETTIM(HR2, MN2, SEC2, HUN2)
      PRINT *, 'AT T= ',T0,'  LYAP-EXPS ARE '
      WRITE(*,25) (APPLES(I),I=1,N)
 25   FORMAT (2X,4(E16.8,2X))
      ACC=0.0D0
      DO 26 I=1,N
 26      ACC=ACC+APPLES(I)
      PRINT*, ' SUM OF THE LES IS ',ACC
      PRINT *
C PRINT SOME STATISTICS
      IF (IPAR(8).EQ.0) THEN
         PRINT *, 'METHOD USED FOR LES IS CONT QR WITH PROJ-DP5 '
        ELSE IF (IPAR(8).EQ.1) THEN
         PRINT *, 'METHOD USED FOR LES IS CONT QR WITH HYBRID-DP5 '
        ELSE IF (IPAR(8).EQ.2) THEN
         PRINT *, 'METHOD USED FOR LES IS CONT QR WITH PROJ-RK38 '
        ELSE IF (IPAR(8).EQ.3) THEN
         PRINT *, 'METHOD USED FOR LES IS CONT QR WITH HYBRID-RK38 '
        ELSE IF (IPAR(8).EQ.4) THEN
         PRINT *, 'METHOD USED FOR LES IS DISC QR WITH DP5 '
        ELSE IF (IPAR(8).EQ.5) THEN
         PRINT *, 'METHOD USED FOR LES IS DISC QR WITH RK38 '
      ENDIF
      IF (IPAR(8).LE.3) THEN
         IF (IPAR(9).EQ.0) THEN
            PRINT *, 'LES BY NU-INTEGRATION '
           ELSE IF (IPAR(9).EQ.1) THEN
            PRINT *, 'LES BY COMP-TRAP-RULE '
         ENDIF
      ENDIF
      IF (IPAR(10).EQ.0) THEN
         PRINT *, 'ERROR CONTROL ON TRAJECTORY '
        ELSE IF (IPAR(10).EQ.1) THEN
         PRINT *, 'ERROR CONTROL ON LES '
        ELSE IF (IPAR(10).EQ.2) THEN
         PRINT *, 'ERROR CONTROL ON Q '
        ELSE IF (IPAR(10).EQ.10) THEN
         PRINT *, 'ERROR CONTROL ON TRAJECTORY AND LES '
        ELSE IF (IPAR(10).EQ.20) THEN
         PRINT *, 'ERROR CONTROL ON TRAJECTORY AND Q '
        ELSE IF (IPAR(10).EQ.21) THEN
         PRINT *, 'ERROR CONTROL ON LES AND Q'
        ELSE IF (IPAR(10).EQ.210) THEN
         PRINT *, 'ERROR CONTROL ON TRAJECTORY, LES AND Q'
      END IF
      PRINT *, 'IFLAG = ', IFLAG, ' FINAL T = ', T0
      PRINT *, 'STEPS REJECTED = ', IPAR(12)
      PRINT *, 'NUMBER OF STEPS = ', IPAR(13)
C     WRITE (6,*) 'INITIAL TIME = ', HR1,MN1,SEC1,HUN1
C     WRITE (6,*) 'FINAL TIME = ', HR2,MN2,SEC2,HUN2

      STOP 
      END

C ... and these are the sample GETF and GETA .... 

      SUBROUTINE GETF(M,X,XDOT,INARR,REARR)

      IMPLICIT NONE

      INTEGER M, INARR(*)
      DOUBLE PRECISION X(M), XDOT(M), REARR(*)

      INTEGER I
      DOUBLE PRECISION SIGMA, BETA, RHO

      DO 15 I=1,M
 15      XDOT(I)=0.D0


CCCCCCC LORENZ PROBLEM
      SIGMA=REARR(1)
      BETA=REARR(2)
      RHO=REARR(3)
      XDOT(1) = SIGMA*(X(2)-X(1))
      XDOT(2) = RHO*X(1)-X(1)*X(3)-X(2) 
      XDOT(3) = X(1)*X(2)-BETA*X(3) 

      RETURN
      END


      SUBROUTINE GETA(M,X,DF,INARR,REARR)
 
      IMPLICIT NONE

      INTEGER M, INARR(*)
      DOUBLE PRECISION X(M), DF(M,M), REARR(*)

      INTEGER I, J
      DOUBLE PRECISION SIGMA, BETA, RHO

      DO 15 I=1,M
         DO 15 J=1,M
 15         DF(I,J)=0.D0

CCCCCCC LORENZ PROBLEM, sigma=16, beta=4, rho=40 or 45.92 
      SIGMA=REARR(1)
      BETA=REARR(2)
      RHO=REARR(3)
      DF(1,1) = -SIGMA
      DF(1,2) = SIGMA
      DF(2,1) = RHO-X(3)
      DF(2,2) = -1.0D0
      DF(2,3) = -X(1) 
      DF(3,1) = X(2)
      DF(3,2) = X(1)
      DF(3,3) = -BETA 

      RETURN
      END

