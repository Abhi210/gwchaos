C ... SAMPLE DRIVER FOR LESNLL...
C LESNLL IS THE CODE FOR APPROXIMATING LYAPUNOV EXPONENTS
C OF LARGE NONLINEAR SYSTEMS.  IN THIS CASE, THE CODE ONLY
C REQUIRES THE ACTION OF THE JACOBIAN MATRIX ON A VECTOR AND
C THIS CAN BE PROVIDED BY THE USER (SEE GETAV) OR INTERNALLY
C COMPUTED BY THE CODE (SEE IPAR(....))
      PROGRAM DRIV
      IMPLICIT NONE
C DECLARE VARIABLES NEEDED BY LESNLL
C VECTOR FIELD GIVEN IN GETF
C JACOBIAN MATRIX TIMES A VECTOR DEFINED IN GETAV, 
C    OR JUST TREAT GETAV AS A DUMMY ARGUMENT
      EXTERNAL GETF, GETAV
      INTEGER M, N
      PARAMETER (M=3,N=3)
      DOUBLE PRECISION T0, TE, DT, APPLES(N), X0(M,N)
      DOUBLE PRECISION TOLL(N), TOLT, TOLQ
      INTEGER IPAR(13), IFLAG, IFDIM
      PARAMETER(IFDIM=M*M+11*M*N+13*M+8*N+63)
      DOUBLE PRECISION FWORK(IFDIM), Y0(M), REARR(3)
      INTEGER I, INARR

      DOUBLE PRECISION ACC
C VARIABLES TO GET CPU TIME
C     INTEGER*2 HR1,HR2,MN1,MN2,SEC1,SEC2,HUN1,HUN2

CCCCCCC INPUT
C ICs
      Y0(1)=0.0D0
      Y0(2)=1.0D0
      Y0(3)=0.0D0
C PARAMETERS FOR LORENZ SYSTEM, sigma=16, beta=4, rho=40 or 45.92 
C     SIGMA
      REARR(1)=16.0D0
C     BETA
      REARR(2)=4.0D0
C     RHO
      REARR(3)=45.92D0
CCCCCCC VARIABLE STEP SIZE -->0, FIXED STEP SIZE -->1
      IPAR(1) = 0
C ERROR TOLERANCES ALL THE SAME
      TOLT=1.D-8
      TOLQ=1.D-8
      DO 2 I=1,N
         TOLL(I) = 1.0D-8
 2    CONTINUE
CCCCCCC FROM T0 TO TE --> IPAR(2)=0, IF IN ONE STEP MODE --> IPAR(2)=1
      T0 = 0.D0
      DT = 1.0D0*1.0D-2   
      TE = 1.0D+2
      IPAR(2) = 0
CCCCCCC IT IS FIRST CALL
      IPAR(3) = 1
C TO USE DEFAULT ICS ON X0, SET IPAR(4) = 0 
      IPAR(4) = 0
CCCCCCC FWORK DIMENSION
      IPAR(5)=IFDIM
C FIRST, WE'LL INTEGRATE A BIT TO GET RID OF TRANSIENT    
      IPAR(6)=1
C DECIDE WHICH METHOD WANT TO USE FOR TRAJECTORY AND/OR LES
C   IPAR(8)=0 (DEFAULT) IS PROJECTION/DP5
C   IPAR(8)=1 IS HYBRID/DP5
C   IPAR(8)=2 IS PROJECTION/RK38
C   IPAR(8)=3 IS HYBRID/RK38
C   IPAR(8)=4 IS DISC QR/DP5
C   IPAR(8)=5 IS DISC QR/RK38
      IPAR(8)=0
C ERROR CONTROL ON TRAJECTORY IS DEFAULT (OR SET IPAR(10)=0)
      IPAR(10)=0
C FIRST CALL TO GETTIM
C     CALL GETTIM(HR1, MN1, SEC1, HUN1)
C INITIALIZE CODE THE VERY FIRST TIME
      CALL INIT(M,N,IPAR,T0,TE,FWORK,IFLAG)
      IF (IFLAG.NE.0) THEN
         PRINT *, 'IFLAG = ', IFLAG
         STOP
      END IF
      CALL LESNLL(GETF,GETAV,M,N,APPLES,T0,TE,DT,Y0,X0,
     *            TOLT,TOLQ,TOLL,IPAR,FWORK,IFLAG,INARR,REARR)
      IF (IFLAG.NE.0) THEN
         PRINT *, 'IFLAG = ', IFLAG
         PRINT*, ' CURRENT T = ', T0,'  SOLUTION IS '
         WRITE(*,25) (Y0(I),I=1,M)
         STOP
      ENDIF
C SECOND CALL TO GETTIM
C     CALL GETTIM(HR2, MN2, SEC2, HUN2)
      PRINT *, 'IFLAG = ', IFLAG
      PRINT*, ' FINAL T = ', T0,'  SOLUTION IS '
      WRITE(*,25) (Y0(I),I=1,M)
      PRINT *, 'STEPS REJECTED = ', IPAR(12)
      PRINT *, 'NUMBER OF STEPS = ', IPAR(13)
C     WRITE (6,*) 'INITIAL TIME = ', HR1,MN1,SEC1,HUN1
C     WRITE (6,*) 'FINAL TIME = ', HR2,MN2,SEC2,HUN2
C NOW WE ARE READY TO FIND THE LYAPUNOV EXPONENTS
      IPAR(3)=1
      IPAR(6)=0
C IF IPAR(7)=1 WE MUST SPECIFY ACTION OF JACOBIAN ON A VECTOR (SEE GETAV)
      IPAR(7)=1
C DECIDE WHICH METHOD TO USE TO APPROXIMATE EXPONENTS
C IN CASE YOU CHOSE IPAR(8)=0,1,2,3
C   IPAR(9)=0 (DEFAULT) IS NU-INTEGRATION 
C   IPAR(9)=1 IS COMPOSITE TRAP-RULE 
      IPAR(9)=0
C DECIDE HOW WANT TO CONTROL ERROR NOW
C ERROR CONTROL OPTIONS AVAILABLE ARE 
C IPAR(10)=0, 1, 2, 10, 20, 21, 210
C SEE DOCUMENTATION FOR MEANINGS AND COMPATIBILITIES
      IPAR(10)=0
      TE=1.0D+3+T0
C FIRST CALL TO GETTIM
C     CALL GETTIM(HR1, MN1, SEC1, HUN1)
C INTEGRATE FROM T0 TO TE
C CALL MAIN ROUTINE
      CALL LESNLL(GETF,GETAV,M,N,APPLES,T0,TE,DT,Y0,X0,
     *            TOLT,TOLQ,TOLL,IPAR,FWORK,IFLAG,INARR,REARR)
      IF (IFLAG.NE.0) THEN
         PRINT *, 'IFLAG = ', IFLAG
         PRINT*, ' CURRENT T = ', T0,'  LYAP-EXPS ARE '
         WRITE(*,25) (APPLES(I),I=1,N)
         STOP
      ENDIF
C SECOND CALL TO GETTIM
C     CALL GETTIM(HR2, MN2, SEC2, HUN2)
      PRINT *, 'AT T= ',T0,'  LYAP-EXPS ARE '
      WRITE(*,25) (APPLES(I),I=1,N)
 25   FORMAT (2X,4(E16.8,2X))
      ACC=0.0D0
      DO 26 I=1,N
 26      ACC=ACC+APPLES(I)
      PRINT*, ' SUM OF THE LES IS ',ACC
      PRINT *
C PRINT SOME STATISTICS
      IF (IPAR(7).EQ.0) THEN
         PRINT *, ' USED INTERNAL JAC*V '
        ELSE 
         PRINT *, ' USED USER JAC*V '
      ENDIF
      IF (IPAR(8).EQ.0) THEN
         PRINT *, 'METHOD USED FOR LES IS CONT QR WITH PROJ-DP5 '
        ELSE IF (IPAR(8).EQ.1) THEN
         PRINT *, 'METHOD USED FOR LES IS CONT QR WITH HYBRID-DP5 '
        ELSE IF (IPAR(8).EQ.2) THEN
         PRINT *, 'METHOD USED FOR LES IS CONT QR WITH PROJ-RK38 '
        ELSE IF (IPAR(8).EQ.3) THEN
         PRINT *, 'METHOD USED FOR LES IS CONT QR WITH HYBRID-RK38 '
        ELSE IF (IPAR(8).EQ.4) THEN
         PRINT *, 'METHOD USED FOR LES IS DISC QR WITH DP5 '
        ELSE IF (IPAR(8).EQ.5) THEN
         PRINT *, 'METHOD USED FOR LES IS DISC QR WITH RK38 '
      ENDIF
      IF (IPAR(8).LE.3) THEN
         IF (IPAR(9).EQ.0) THEN
            PRINT *, 'LES BY NU-INTEGRATION '
           ELSE IF (IPAR(9).EQ.1) THEN
            PRINT *, 'LES BY COMP-TRAP-RULE '
         ENDIF
      ENDIF
      IF (IPAR(10).EQ.0) THEN
         PRINT *, 'ERROR CONTROL ON TRAJECTORY '
        ELSE IF (IPAR(10).EQ.1) THEN
         PRINT *, 'ERROR CONTROL ON LES '
        ELSE IF (IPAR(10).EQ.2) THEN
         PRINT *, 'ERROR CONTROL ON Q '
        ELSE IF (IPAR(10).EQ.10) THEN
         PRINT *, 'ERROR CONTROL ON TRAJECTORY AND LES '
        ELSE IF (IPAR(10).EQ.20) THEN
         PRINT *, 'ERROR CONTROL ON TRAJECTORY AND Q '
        ELSE IF (IPAR(10).EQ.21) THEN
         PRINT *, 'ERROR CONTROL ON LES AND Q'
        ELSE IF (IPAR(10).EQ.210) THEN
         PRINT *, 'ERROR CONTROL ON TRAJECTORY, LES AND Q'
      END IF
      PRINT *, 'IFLAG = ', IFLAG, ' FINAL T = ', T0
      PRINT *, 'STEPS REJECTED = ', IPAR(12)
      PRINT *, 'NUMBER OF STEPS = ', IPAR(13)
C     WRITE (6,*) 'INITIAL TIME = ', HR1,MN1,SEC1,HUN1
C     WRITE (6,*) 'FINAL TIME = ', HR2,MN2,SEC2,HUN2

      STOP 
      END

C ... and these are the sample GETF and GETAV .... 

      SUBROUTINE GETF(M,Y,YDOT,INARR,REARR)

      IMPLICIT NONE

      INTEGER M, INARR(*)
      DOUBLE PRECISION Y(M), YDOT(M), REARR(*)

      INTEGER I
      DOUBLE PRECISION SIGMA, BETA, RHO

      DO 15 I=1,M
 15      YDOT(I)=0.D0

CCCCCCC LORENZ PROBLEM, sigma=16, beta=4, rho=40 or 45.92 
      SIGMA=REARR(1)
      BETA=REARR(2)
      RHO=REARR(3)
      YDOT(1) = SIGMA*(Y(2)-Y(1))
      YDOT(2) = RHO*Y(1)-Y(1)*Y(3)-Y(2) 
      YDOT(3) = Y(1)*Y(2)-BETA*Y(3) 

      RETURN
      END


      SUBROUTINE GETAV(M,Y,V,DFV,INARR,REARR)
 
      IMPLICIT NONE

      INTEGER M, INARR(*)
      DOUBLE PRECISION Y(M), V(M), DFV(M), REARR(*)

      INTEGER I
      DOUBLE PRECISION SIGMA, BETA, RHO

      DO 15 I=1,M
 15      DFV(I)=0.D0

CCCCCCC LORENZ PROBLEM
      SIGMA=REARR(1)
      BETA=REARR(2)
      RHO=REARR(3)
      DFV(1)=SIGMA*(-V(1)+V(2))
      DFV(2) = (RHO-Y(3))*V(1)-V(2)-Y(1)*V(3)
      DFV(3) = Y(2)*V(1)+Y(1)*V(2)-BETA*V(3)

      RETURN
      END

